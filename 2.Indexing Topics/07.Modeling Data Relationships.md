## **1. 핵심 모델링 원칙**
### **"Data that is accessed together should be stored together"**
MongoDB는 관계형 데이터베이스와 달리 비정규화된 데이터 구조를 사용합니다. 따라서 자주 함께 조회되는 데이터를 한 문서에 저장하면 쿼리 성능이 크게 향상됩니다.

#### **예제: 블로그 게시글과 댓글**
- 블로그 게시글(Post)과 댓글(Comment)이 자주 함께 조회된다면 댓글 데이터를 게시글 문서에 임베딩하여 저장.
```javascript
{
  "_id": "post001",
  "title": "MongoDB Modeling Guide",
  "comments": [
    { "commentId": "cmt001", "text": "Great post!" },
    { "commentId": "cmt002", "text": "Very helpful." }
  ]
}
```
- 반면, 댓글이 독립적으로 관리되거나 수가 많아질 경우 참조 방식으로 분리.
```javascript
// Post 컬렉션
{
  "_id": "post001",
  "title": "MongoDB Modeling Guide"
}

// Comment 컬렉션
{
  "_id": "cmt001",
  "postId": "post001",
  "text": "Great post!"
}
```

---

## **2. 임베딩(Embedding) vs 참조(Referencing) 선택 가이드라인**

임베딩과 참조를 선택할 때 다음의 가이드라인을 고려해야 합니다:

| **가이드라인**       | **설명**                                                                                      | **임베딩 권장**                                                                                   | **참조 권장**                                                                                     |
|----------------------|----------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|
| **Simplicity (단순성)** | 데이터 구조가 단순하고 자주 함께 조회될 때.                                                    | 데이터를 한 문서에 포함하여 단순하게 관리.                                                        | 독립적으로 관리해야 할 때 별도 컬렉션으로 분리.                                                   |
| **Go Together (함께 조회)** | 데이터를 항상 함께 조회할 때 적합.                                                          | 부모-자식 관계를 하나의 문서로 저장.                                                              | 독립적으로 조회되거나 부모와 자식이 자주 분리될 때.                                              |
| **Query Atomicity (쿼리 원자성)** | 다수의 관련 데이터를 한 번에 업데이트해야 할 때 적합.                                      | 모든 데이터를 하나의 문서에 포함하여 트랜잭션 없이 원자성을 보장.                                   | 독립적인 업데이트가 필요할 때 별도 컬렉션으로 분리.                                               |
| **Update Complexity (업데이트 복잡성)** | 자식 데이터가 자주 업데이트되거나 크기가 커질 경우 적합하지 않음.                              | 부모와 자식이 함께 업데이트될 경우 적합.                                                          | 자식 데이터가 자주 변경되거나 크기가 커질 경우 별도로 관리.                                       |
| **Archival (보관성)**   | 오래된 데이터를 보관하거나 삭제할 때 유연성이 필요할 경우.                                         | 보관 또는 삭제가 필요 없는 경우 적합.                                                             | 오래된 데이터를 독립적으로 관리해야 할 때 적합.                                                   |
| **Cardinality (카디널리티)** | 자식 데이터의 개수가 적은 경우 임베딩, 많은 경우 참조 방식이 적합.                                 | 댓글 수가 적은 블로그 게시글처럼 자식 데이터가 제한적일 때 임베딩 사용.                             | 자식 데이터가 많아질 가능성이 높은 경우 참조 방식 사용(예: 대규모 리뷰 시스템).                    |
| **Data Duplication (데이터 중복)** | 중복을 허용할 수 있는지 여부에 따라 결정.                                                  | 중복을 허용할 수 있는 경우(읽기 성능 우선).                                                        | 중복을 최소화해야 하는 경우(쓰기 성능 우선).                                                       |
| **Document Size (문서 크기)**   | MongoDB 문서 크기 제한(16MB)을 초과하지 않도록 주의해야 함.                                    | 문서 크기가 작고 제한 내에 있을 경우 임베딩 사용 가능.                                             | 문서 크기가 크거나 제한을 초과할 가능성이 있을 경우 참조 방식 사용 필요.                          |
| **Document Growth (문서 성장)**   | 문서 내부 배열이나 필드가 지속적으로 증가할 가능성이 있는지 분석 필요.                          | 배열 크기가 작고 고정적일 경우 임베딩 사용 가능.                                                   | 배열이 지속적으로 증가하거나 동적일 경우 참조 방식 사용 필요.                                      |
| **Workload (작업 부하)**       | 읽기 작업이 많은지 쓰기 작업이 많은지에 따라 결정.                                           | 읽기 작업이 많고 쓰기 작업이 적다면 임베딩 사용 권장.                                              | 쓰기 작업이 많고 읽기 작업이 적다면 참조 방식 권장.                                                |
| **Individuality (독립성)**     | 자식 데이터가 독립적으로 관리되어야 하는지 여부를 고려해야 함.                                   | 부모-자식 관계가 강하게 결합되어 있다면 임베딩 사용 권장(예: 사용자 프로필과 설정).                 | 자식 데이터가 독립적으로 관리되어야 한다면 참조 방식 권장(예: 학생과 강좌 간 관계).                |

---

## **3. 실제 사용 사례 및 고급 사용 사례**

### **3.1 전자상거래 플랫폼**
#### 요구사항:
- 제품(Product)과 리뷰(Review)를 관리.
#### 설계:
- 리뷰 개수가 적을 때는 제품에 리뷰를 임베딩.
- 리뷰 개수가 많아질 경우 최신 리뷰만 임베딩하고 나머지는 참조로 관리(Subset Pattern).
```javascript
{
   "_id": "product001",
   "name": "Smartphone",
   "reviews": [
      { "_id": "review001", "text": "Excellent!", "rating": 5 },
      { "_id": "review002", "text": "Good value.", "rating": 4 }
   ]
}
```

---

### **3.2 소셜 미디어 플랫폼**
#### 요구사항:
- 사용자(User)와 팔로워(Follower)를 관리.
#### 설계:
- 팔로워 정보는 자주 업데이트되므로 별도의 컬렉션으로 관리.
```javascript
// User 컬렉션
{
   "_id": "user001",
   "name": "John Doe"
}

// Follower 컬렉션
{
   "_id": ObjectId(),
   userId: ObjectId("user001"),
   followerId: ObjectId("user002")
}
```

---

## **4. 성능 최적화 및 문제 해결**

### 성능 최적화 팁
1. **인덱스 생성**:
   - 참조 방식에서는 외래 키 필드에 인덱스를 생성하여 조회 성능을 향상시킵니다.
   ```javascript
   db.comments.createIndex({ postId: 1 });
   ```

2. **쿼리 패턴 분석**:
   - 애플리케이션에서 가장 빈번히 수행되는 쿼리를 기준으로 스키마 설계.

3. **데이터 중복 허용**:
   - 읽기 성능이 중요한 경우 필요한 데이터를 중복 저장하여 쿼리 횟수를 줄입니다.

---

### 문제 해결 사례

#### 문제: `$lookup` 단계에서 느린 쿼리 속도
**원인**:
- 조인 대상 컬렉션에 인덱스가 없거나 너무 큰 데이터셋 처리.

**해결책**:
1. 조인 필드에 인덱스 추가.
2. 필요한 필드만 반환하도록 `$project` 추가.

```javascript
db.posts.aggregate([
   {
      $lookup: {
         from: 'comments',
         localField: '_id',
         foreignField: 'postId',
         as: 'comments'
      }
   },
   { $project: { title: 1, comments.text: 1 } }
]);
```

